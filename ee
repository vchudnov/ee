#!/bin/bash
# ee: A shell script to start and connect to named emacs servers
# Copyright 2010 Victor Chudnovsky
#
# Author: victor.chudnovsky+ee@gmail.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# Description:
#
# This shell script can be used to start a new named emacs server
# process, or to connect to an already running emacs server process
# with the given name. You can also connect to a singleton unnamed
# emacs server, which is useful if you set the EDITOR shell variable
# to be this script. If the desktop-autosave.el package is installed,
# this script will also start autosaving the desktop, so that you can
# quickly recover context should your session ever die or hang.
#
# Usage: Run this script with the --help flag to see a summary of the
# usage.
#
#    ee -c SERVER FILE.... 
#      connects to SERVER (creating it if necessary) and opens
#      FILE... in a new frame (X or text). The buffer persists even when
#      the frame is closed
#    ee FILE...
#      connects to an unnamed emacs daemon (creating it if necessary)
#      and opens FILE... in a new frame (X or text). The buffer is
#      removed from the server when the frame is closed. This is ideal
#      for using as the value of \$EDITOR
#    ee -l
#      lists all the desktop sessions that have been saved.
#    ee -k SERVER
#      kills the specified running emacs server
#    ee --killall
#      kills all the running emacs servers
#    ee -d SERVER
#      deletes from disk the specified emacs server's desktop file
#    ee --deleteall
#      deletes from disk all the emacs servers' desktop files
#    ee --debug ...
#      displays additional trace information while executing this script
#    ee  --help
#      displays this message
#
#   Advanced  flags (used for bash autocompletion, typically in ee_autocomplete.sh):
#     --user_flags
#       list of flags users would typically use to invoke ee on the
#       command line.
#     --flags_taking_sessions
#       list of flags whose values could be an existing emacs server or
#       desktop name. This list is formatted for use in a bash case
#       statement.
#
# Installation:
# 1. Put the ee script somewhere on your path
# 2. If desired, install the desktop-autosave.el package so that it gets
#    loaded when emacs starts
# 3. Put the ee_autcomplete.sh script somewhere (either at the system
#    level in /etc/bash_completion.d or under your home directory)
# 4. Add the following to your .bashrc so that the ee_autocomplete.sh script gets
#    sourced:
#      . <PATH_TO_EE_AUTOCOMPLETE>/ee_autocomplete.sh
# 5. Add the following to your .bashrc in order to have your deault
#    system editor come up quickly (since this will be a persitent emacs
#    server only instantiated once):
#      export EDITOR=ee


# list_sessions
# List all the desktop sessions under $EMACS_DESKTOP_REPOSITORY.
function list_sessions() {
    pushd "$EMACS_DESKTOP_REPOSITORY" >& /dev/null
    if [[ $? ]]; then
	ls */.emacs.desktop 2> /dev/null | sed 's/\([^\/]\)\(\/\.emacs\.desktop\)/\1/'
	popd >& /dev/null
    fi
}

# decho MESSAGE
# Echo a message only in debug mode
function decho() {
    if [[ "$DEBUG" ]]; then
	echo "$*"
    fi
}

# call_emacs DESKTOP_SOCKET DETACH_CMD EMACS_EVAL USE_ALTERNATE_EDITOR
# Invoke emacsclient using DESKTOP_SOCKET and passing DETACH_CMD as a
# flag determining whether to detach from the terminal or not. Also
# cause emacs to evaluate EMACS_EVAL. Tell emacsclient to use an
# alternate editor if USE_ALTERNATE_EDITOR is non-empty; otherwise
# tell emacs to start the server.
function call_emacs() {
    local DESKTOP_SOCKET="$1"
    local DETACH="$2"
    local EVAL="$3"
    if [[ -n "$4" ]]; then
	local ALTERNATE="-a \"\""
    fi
    if  [[ -n "$EVAL" ]]; then
	local DOEVAL="--eval"
	local EVAL="(progn $EVAL )"
    fi
    local CMD="unset ALTERNATE_EDITOR ; emacsclient -c -s \"$DESKTOP_SOCKET\" $DETACH $ALTERNATE $DOEVAL \"\$EVAL\" $REDIRECTION"
    if [[ "$DEBUG" ]]; then
	echo "EVAL:           $EVAL"
	echo "$CMD"
    fi
    eval $CMD
}

# confirm PROMPT
# Print a confirmation prompt and process the user response. A return
# value of 0 corresponds to a user reply of "yes".
function confirm() {
    read -p "$1"
    [[ $REPLY =~ ^[Yy].*$ ]]
    return $?
}

# kill_emacs SESSION
# Kill the running emacs server named SESSION after getting
# confirmation from the user. A return value of 1 means something was
# killed.
function kill_emacs() {
    local DESKTOP_SOCKET_DIR="/tmp/ee/$1"
    local DESKTOP_SOCKET="$DESKTOP_SOCKET_DIR/.socket"
    confirm "Really kill session $1? "
    if (( ! $? )); then
	call_emacs "$DESKTOP_SOCKET" "-n" \
	    "(progn (if (fboundp 'desktop-autosave-stop) (desktop-autosave-stop t)) (kill-emacs))"
	if (( ! $? )); then
	    return 1
	fi
    fi
    return 0
}

# delete_session SESSION
# Delete the desktop session SESSION under ${EMACS_DESKTOP_REPOSITORY}
# after getting confirmation from the user. A return value of 1 means
# something was killed.
function delete_session() {
    local DESKTOP_DIR="${EMACS_DESKTOP_REPOSITORY}/$1"
    confirm "Really delete ${DESKTOP_DIR}? "
    if (( ! $? )); then
	rm -r "${DESKTOP_DIR}"
	if (( ! $? )); then
	    return 1
	fi
    fi
    return 0
}

# destroy_all things DESTROY_FUNCTION DESTROY_LABEL
# Utility function to either kill or delete all ee sessions, since
# both operations follow a similar pattern.  The function actually
# used to perform the destructive operation is DESTROY_FUNCTION. It is
# referred to in user messages as DESTROY_LABEL.
function destroy_all_things() {
    local destroy_function="$1"
    local destroy_label="$2"
    local exit_code=0
    for session in $(list_sessions) ; do
	"$destroy_function" "$session"
	if (( $? )); then
	    echo "Completed $destroy_label on $session"
	else
	    decho "Could not $destroy_label $session"
	    exit_code=1
	fi
    done
    exit $exit_code
}

# destroy_one thing DESTROY_FUNCTION DESTROY_LABEL DESTROY_TARGET
# Utility function to either kill or delete the particular ee session
# DESTROY_TARGET, since both operations follow a similar pattern.  The
# function actually used to perform the destructive operation is
# DESTROY_FUNCTION. It is referred to in user messages as
# DESTROY_LABEL.
function destroy_one_thing() {
    local destroy_function="$1"
    local destroy_label="$2"
    local destroy_target="$3"
    if [[ -z "${destroy_target}" ]]; then
	echo "$0: No session to ${destroy_label} specified"
	exit -1
    fi
    if [[ "$(list_sessions | grep "$destroy_target" )" ]]; then
	"$destroy_function" "$destroy_target"
	exit $?
    else
	echo "$0: The specified desktop session to $destroy_label has not been found. Aborting."
	exit -1
    fi
}

if [[ "$1" == "--help" ]]; then
    cat <<EOF
 $0 [--debug] [--tty] [-c SERVER] [FILE...]
 Run emacs in daemon/client mode, starting the emacs desktop-autosave package
 if available.
   $0 -c SERVER FILE.... 
     connects to SERVER (creating it if necessary) and opens
     FILE... in a new frame (X or text). The buffer persists even when
     the frame is closed
   $0 FILE...
     connects to an unnamed emacs daemon (creating it if necessary)
     and opens FILE... in a new frame (X or text). The buffer is
     removed from the server when the frame is closed. This is ideal
     for using as the value of \$EDITOR
   $0 -l
     lists all the desktop sessions that have been saved.
   $0 -k SERVER
     kills the specified running emacs server
   $0 --killall
     kills all the running emacs servers
   $0 -d SERVER
     deletes from disk the specified emacs server's desktop file
   $0 --deleteall
     deletes from disk all the emacs servers' desktop files
   $0 --tty ....
     runs in terminal mode, even in an X session
   $0 --debug ...
     displays additional trace information while executing this script
   $0  --help
     displays this message

  Advanced  flags (used for bash autocompletion, typically in ee_autocomplete.sh):
    --user_flags
      list of flags users would typically use to invoke ee on the
      command line.
    --flags_taking_sessions
      list of flags whose values could be an existing emacs server or
      desktop name. This list is formatted for use in a bash case
      statement.

EOF
elif [[ "$1" == "--user_flags" ]]; then
    echo "-c -l -k --killall -d --deleteall --help --debug --user_flags --tty"
elif [[ "$1" == "--flags_taking_sessions" ]]; then
    echo "-c|-k|-d"
else
    if [[ "$1" == "--debug" ]] ; then
	DEBUG="true"
	REDIRECTION=""
	shift
    else
	DEBUG=""

	# Only redirect stdout if we're not in a tty--otherwise
	# there's no output device!
	if [[ -z "$DISPLAY" ]]; then
	    REDIRECTION="2> /dev/null"
	else
	    REDIRECTION=">& /dev/null"
	fi
    fi
    if [[ "$1" == "--tty" ]] ; then
	TTY="true"
	shift
    else
	TTY=""
    fi
    if [[ -z "$EMACS_DESKTOP_REPOSITORY" ]]; then
	EMACS_DESKTOP_REPOSITORY="${HOME}/.emacs.d/desktop-sessions"
    fi
    
    if [[ "$1" == "-l" ]]; then
	list_sessions
    elif [[ "$1" == "-k" ]]; then
	destroy_one_thing kill_emacs "kill" "$2"
    elif [[ "$1" == "--killall" ]]; then
	destroy_all_things kill_emacs "kill"
    elif [[ "$1" == "-d" ]]; then
	destroy_one_thing delete_session "delete" "$2"
    elif [[ "$1" == "--deleteall" ]]; then
	destroy_all_things delete_session "delete"
    else
	DETACH=""
	EVAL=""
	XDEFAULTS_LOCATION="$HOME/.Xdefaults"
	if [[ -n "$TTY" ]]; then
	    DETACH="-nw"
	fi
	if [[ "$1" == "-c" ]]; then
            # We only detach if it's a named server AND we have an X display AND --tty was not specified.
	    if [[ -n "$DISPLAY"  && -z "$TTY" ]]; then
		if [[ -n "$XDEFAULTS_LOCATION" ]]; then
                     # ensure that the X settings for emacs are up to date
		    xrdb -merge "$XDEFAULTS_LOCATION"
		fi
		DETACH="-n"
	    fi
	    DESKTOP_NAME="$2"
	    shift
	    shift
	    DESKTOP_AUTOSAVE_FORCE="nil"
	else
	    DESKTOP_NAME="ee-desktop"
	    DESKTOP_AUTOSAVE_FORCE="t"
	fi

	DESKTOP_DIR="$EMACS_DESKTOP_REPOSITORY/$DESKTOP_NAME"
	DESKTOP_SOCKET_DIR="/tmp/ee/$DESKTOP_NAME"
	DESKTOP_SOCKET="$DESKTOP_SOCKET_DIR/.socket"

	mkdir -p "$DESKTOP_DIR"
	mkdir -p "$DESKTOP_SOCKET_DIR"

	SERVER_ACCESS="-s \"$DESKTOP_NAME\" -n"

	EVAL="$EVAL (if (fboundp 'desktop-autosave-start) (desktop-autosave-start  \"${DESKTOP_NAME}\" $DESKTOP_AUTOSAVE_FORCE))"

        # If we just had one file, -c $FILE would work to load and display
        # the one file. In case more than one file is specified, we load
        # and display the first one and just pre-load all the others. We
        # do this by using elisp expressions.  Refer to
        # http://www.gnu.org/s/emacs/manual/html_node/elisp/Visiting-Functions.html#Visiting-Functions

	if [[ -n "$1" ]]; then
	    EVAL="$EVAL (find-file \"$1\")"
	    shift
	fi

	while [[ -n "$1" ]]; do
	    EVAL="$EVAL (find-file-noselect \"$1\" )"
	    shift
	done
	ALTERNATE=yes

	call_emacs  "$DESKTOP_SOCKET" "$DETACH" "$EVAL" "$ALTERNATE"
    fi
fi # do something